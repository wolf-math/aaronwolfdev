"use strict";(globalThis.webpackChunkaaronwolf_dev=globalThis.webpackChunkaaronwolf_dev||[]).push([[3729],{414:e=>{e.exports=JSON.parse('{"permalink":"/blog/temporal-datetime","editUrl":"https://github.com/wolf-math/aaronwolfdev/tree/main/blog/2022-09-11-temporal-datetime.md","source":"@site/blog/2022-09-11-temporal-datetime.md","title":"Temporal Date API","description":"This blog post was originally published on dev.to","date":"2022-09-11T00:00:00.000Z","tags":[{"inline":false,"label":"javascript","permalink":"/blog/tags/javascript","description":"javascript articles"}],"readingTime":5.13,"hasTruncateMarker":true,"authors":[{"name":"Aaron wolf","title":"Lead writer and developer","url":"https://aaronwolf.dev","page":{"permalink":"/blog/authors/wolf"},"socials":{"linkedin":"https://www.linkedin.com/in/wolf-math/","github":"https://github.com/wolf-math"},"imageURL":"https://avatars.githubusercontent.com/u/29966332?v=4","key":"wolf"}],"frontMatter":{"slug":"temporal-datetime","title":"Temporal Date API","authors":"wolf","tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Encryption Part 1: Overview","permalink":"/blog/encryption1"},"nextItem":{"title":"Drag and drop from scratch with React","permalink":"/blog/react-dnd"}}')},6990:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var a=t(414),o=t(4848),s=t(8453);const i={slug:"temporal-datetime",title:"Temporal Date API",authors:"wolf",tags:["javascript"]},r="The paradigm shift",d={authorsImageUrls:[void 0]},c=[{value:"<code>PlainDate</code>",id:"plaindate",level:3},{value:"<code>PlainTime</code>",id:"plaintime",level:3},{value:"<code>PlainDateTime</code>",id:"plaindatetime",level:3},{value:"<code>ZonedDateTime</code>",id:"zoneddatetime",level:3},{value:"<code>Instant</code>",id:"instant",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["This blog post was originally published on ",(0,o.jsx)(n.a,{href:"https://dev.to/wolfmath/temporal-date-api-ecb",children:"dev.to"})]})}),"\n",(0,o.jsxs)(n.p,{children:["We all know that dates in JavaScript suck. Temporal is the API that we will come to succeed the legacy date API in JavaScript. This post is about my experience with the new ",(0,o.jsx)(n.a,{href:"https://tc39.es/proposal-temporal/",children:"Temporal API"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["At the moment (no pun intended), Temporal is still in stage 3 (out of 4) of development. This means that it should not be used in development, but if you're curious on how to use it you can still use the ",(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/@js-temporal/polyfill",children:"Temporal polyfill"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The reason why I'm writing this- despite there being a plethora of other tutorials- is because I haven't seen others showcase how Temporal might be used in the real world. However, this is not a comprehensive overview of the entire API."}),"\n",(0,o.jsxs)(n.p,{children:["In order to understand Temporal dates one must think about dates differently. In Legacy JavaScript dates are ultimately wrappers for epoch milliseconds. While Temporal dates ",(0,o.jsx)(n.em,{children:"can"})," do this, they are not necessarily this. This means that you can have a Temporal Date object (or a time object) that is completely divorced from epoch milliseconds."]}),"\n",(0,o.jsx)(n.h1,{id:"most-common-use-cases-for-me-at-least",children:"Most common use cases (for me at least)"}),"\n",(0,o.jsxs)(n.p,{children:["As far as I understand the naming convention, anything that begins with ",(0,o.jsx)(n.code,{children:"Plain"})," is disconnected from epoch milliseconds."]}),"\n",(0,o.jsx)(n.h3,{id:"plaindate",children:(0,o.jsx)(n.code,{children:"PlainDate"})}),"\n",(0,o.jsx)(n.p,{children:"One can create a plain date like so:"}),"\n",(0,o.jsx)(n.p,{children:"input:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// today can be an ISO string or an object\nconst today = '2022-09-10'\n// or \n// const today = { year: 2022, month: 9, day: 10 }\nconst temporalToday = Temporal.PlainDate.from(today)\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"temporalToday"})," is an object with the following characteristics:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"{\n  calendar: Calendar {\n    id: 'iso8601'},\n  day: 10,\n  dayOfWeek: 6,\n  dayOfYear: 253,\n  daysInMonth: 30,\n  daysInWeek: 7,\n  daysInYear: 365,\n  era: undefined,\n  eraYear: undefined,\n  inLeapYear: false,\n  month: 9,\n  monthCode: \"M09\",\n  monthsInYear: 12,\n  weekOfYear: 36,\n  year: 2022\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can see that this provides a lot more information that simply the year, month, and date. Also, it's implied that the preferred calendar is iso8601, but there are other calendars that can be used, such as the Jewish or Chinese calendars."}),"\n",(0,o.jsx)(n.h3,{id:"plaintime",children:(0,o.jsx)(n.code,{children:"PlainTime"})}),"\n",(0,o.jsxs)(n.p,{children:["Similar to ",(0,o.jsx)(n.code,{children:"PlainDate"})," if the following is instantiated:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const time = '13:55:14'\nconst plainTimeNow = Temporal.PlainTime.from(time)\n"})}),"\n",(0,o.jsx)(n.p,{children:"The following object will be returned:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"{\n  calendar: Calendar {\n    id: 'iso8601'},\n  hour: 13,\n  microsecond: 0,\n  millisecond: 0,\n  minute: 55,\n  nanosecond: 0,\n  second: 14\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"plaindatetime",children:(0,o.jsx)(n.code,{children:"PlainDateTime"})}),"\n",(0,o.jsxs)(n.p,{children:["Like ",(0,o.jsx)(n.code,{children:"PlainDate"})," and ",(0,o.jsx)(n.code,{children:"PlainTime"}),", this returns an object, but with the attributes of both of them together. Remember that the input must be in ISO format or an object."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const dateTime = '2022-09-10T13:55:14'\n// or\n// const dateTime = {\n//   year: 2022,\n//   month: 9,\n//   day: 10,\n//   hour: 13,\n//   minute: 55,\n//   second: 14\n// }\n\nconst dateTimeNow = Temporal.PlainDateTime.from(dateTime)\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'{\n  ...\n  day: 10\n  dayOfWeek: 6\n  dayOfYear: 253,\n  daysInMonth: 30,\n  daysInWeek: 7,\n  daysInYear: 365,\n  era: undefined,\n  eraYear: undefined,\n  hour: 13,\n  inLeapYear: false,\n  microsecond: 0,\n  millisecond: 0,\n  minute: 55,\n  month: 9,\n  monthCode: "M09",\n  monthsInYear: 12,\n  nanosecond: 0,\n  second: 14,\n  weekOfYear: 36,\n  year: 2022\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This is pretty self explanatory once the previous 2 sections are understood."}),"\n",(0,o.jsx)(n.h3,{id:"zoneddatetime",children:(0,o.jsx)(n.code,{children:"ZonedDateTime"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that ",(0,o.jsx)(n.code,{children:"ZonedDateTime"}),' isn\'t preceded by the work "plain". This is because there is a full time ',(0,o.jsx)(n.em,{children:"and"})," location, and therefore epoch milliseconds can be calculated."]}),"\n",(0,o.jsxs)(n.p,{children:["Note that only an object or ",(0,o.jsx)(n.a,{href:"https://tc39.es/proposal-temporal/docs/zoneddatetime.html#new-Temporal-ZonedDateTime",children:"epoch nanoseconds"})," can be passed into ",(0,o.jsx)(n.code,{children:"ZonedDateTime"}),". I don't have a sample of using epoch nanoseconds since it's outside of my use case."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const hereAndNow = {\n  year: 2020,\n  month: 9,\n  day: 10,\n  hour: 13,\n  minute: 55,\n  second: 14,\n  timeZone: 'America/New_York'\n}\nconst zonedDateTime = Temporal.ZonedDateTime.from(hereAndNow)\n"})}),"\n",(0,o.jsx)(n.p,{children:"This will produce:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'{\n  day: 10,\n  dayOfWeek: 4,\n  dayOfYear: 254,\n  daysInMonth: 30,\n  daysInWeek: 7,\n  daysInYear: 366,\n  epochMicroseconds: 1599760514000000n,\n  epochMilliseconds: 1599760514000,\n  epochNanoseconds: 1599760514000000000n,\n  epochSeconds: 1599760514,\n  era: undefined,\n  eraYear: undefined,\n  hour: 13,\n  hoursInDay: 24,\n  inLeapYear: true,\n  microsecond: 0,\n  millisecond: 0,\n  minute: 55,\n  month: 9,\n  monthCode: "M09",\n  monthsInYear: 12,\n  nanosecond: 0,\n  offset: "-04:00",\n  offsetNanoseconds: -14400000000000,\n  second: 14,\n  timeZone: {\n    id: "America/New_York",\n  },\n  weekOfYear: 37,\n  year: 2020,\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Look at all those attributes available to us! Notice that the ",(0,o.jsx)(n.code,{children:"epochMilliseconds"})," are there along with ",(0,o.jsx)(n.code,{children:"epochMircoseconds"})," and others."]}),"\n",(0,o.jsx)(n.p,{children:"This makes saving this information to the database extremely easy."}),"\n",(0,o.jsx)(n.h3,{id:"instant",children:(0,o.jsx)(n.code,{children:"Instant"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Instant"})," can be instantiated from ",(0,o.jsx)(n.em,{children:"either"})," a date string, or a number. The number can be epoch milliseconds, nanoseconds, or microseconds. Since I work with epoch milliseconds, that's what I'll show. Assume my timezone is UTC right now."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const todayString = '2022-09-10T13:55Z'\nconst todayMilliseconds = 1662818100000\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note: There is an added ",(0,o.jsx)(n.code,{children:"Z"})," at the end of the string date to denote the timezone."]}),"\n",(0,o.jsx)(n.p,{children:"There's also a slight difference to how one interacts with the two different types of dates."}),"\n",(0,o.jsxs)(n.p,{children:["Note: Objects cannot be passed in as an argument the way we did above with the ",(0,o.jsx)(n.code,{children:"Plain"})," Temporal objects."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const fromString = Temporal.Instant.from(todayString)\nconst fromMilliseconds = \n  Temporal.Instant.fromEpochMilliseconds(todayMilliseconds)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Both of these are the same date so they will output the same information."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"{\n  epochMicroseconds: 1662818100000000n\n  epochMilliseconds: 1662818100000\n  epochNanoseconds: 1662818100000000000n\n  epochSeconds: 1662818100\n}\n"})}),"\n",(0,o.jsx)(n.h1,{id:"coercion",children:"Coercion"}),"\n",(0,o.jsxs)(n.p,{children:["The biggest frustration I had was figuring out how to coerce a ",(0,o.jsx)(n.code,{children:"Plain"})," object into an ",(0,o.jsx)(n.code,{children:"Instant"})," and vice versa. ",(0,o.jsx)(n.strong,{children:"This section is the reason I'm writing this piece"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The problem I encountered was ",(0,o.jsx)(n.strong,{children:"how do I read epochMilliseconds and coerce them into other Temporal types?"})]}),"\n",(0,o.jsxs)(n.p,{children:["The answer! ",(0,o.jsx)(n.code,{children:"with"})," and ",(0,o.jsx)(n.code,{children:"to"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's say I had a value in the db called ",(0,o.jsx)(n.code,{children:"createdAt"})," (really clever, I know) which is stored as a UTC timestamp. How could this be coerced into a Temporal object (PlainTime, PlainDate, or PlainDateTime)?"]}),"\n",(0,o.jsxs)(n.p,{children:["The first step is to convert that into a ",(0,o.jsx)(n.code,{children:"ZonedDateTime"}),". But before doing that a timezone is required. For this I'm going to use my local timezone."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const myTZ = Temporal.timezone.from('America/New_York')\nconst createdAt = 1662818100000\nconst createdAtInstant = \n  Temporal.Instant.fromEpochMilliseconds(createdAt)\nconst zonedCreatedAt = createdAtInstant.toZonedDateTime({\n  timeZone: tz,\n  calendar: 'iso8601'\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It's a bit much, but now ",(0,o.jsx)(n.code,{children:"zonedCreatedAt"})," is a Temporal ",(0,o.jsx)(n.code,{children:"ZonedDateTime"})," created from an instant that was created from an epoch millisecond timestamp."]}),"\n",(0,o.jsxs)(n.p,{children:["If you wanted to convert the above to another Temporal type ",(0,o.jsx)(n.code,{children:"toPlainDate"})," and ",(0,o.jsx)(n.code,{children:"toPlainTime"})," can be used on ",(0,o.jsx)(n.code,{children:"zonedCreatedAt"}),"."]}),"\n",(0,o.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"This was a bit of a primer. If you go through the documentation there are other ways to do some of the things I showed above and there are more details to know."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(6540);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);